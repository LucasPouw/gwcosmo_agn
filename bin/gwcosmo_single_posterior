#!/usr/bin/python

"""
This script computes H0 as a function of H0 bins.
"""
__author__ = "Ignacio Magana Hernandez <ignacio.magana@ligo.org>"

# System imports
import os
import sys
from optparse import Option, OptionParser

#Global Imports
import numpy as np
import matplotlib 
matplotlib.use('agg')
import matplotlib.pyplot as plt
from scipy.integrate import quad, dblquad

import time

# Command line options
parser = OptionParser(
    description = __doc__,
    usage = "%prog [options]",
    option_list = [
        Option("-m", "--method", metavar="METHOD", default='counterpart',
            help="METHOD: Select counterpart/statistical/pencil_beam method (required)"),
        Option("-u", "--min_h0", metavar="MINH0", default='10.0',
            help="MINH0: Set minimum value of H0 Posterior"),
        Option("-v", "--max_h0", metavar="MAXH0", default='220.0',
            help="MAXH0: Set maximum value of H0 Posterior"),
        Option("-x", "--bins_h0", metavar="BINSH0", default='50',
            help="BINSH0: Set number of H0 Posterior bins"),
        Option("-d", "--min_dist", metavar="MINDIST", default='0.1', type=float,
            help="MINDIST: Set minimum value of luminosity distance"),
        Option("-e", "--max_dist", metavar="MAXDIST", default='400.0', type=float,
            help="MAXDIST: Set maximum value of luminosity distance"),
        Option("-f", "--bins_dist", metavar="BINSDIST", default='50', type=int,
            help="BINSDIST: Set number of luminosity distance bins"),
        Option("-g", "--galaxy_catalog", metavar="CATALOG", default=None,
            help="CATALOG: Galaxy catalog file in hdf5 format"),
        Option("-w", "--galaxy_weighting", metavar="WEIGHTING", default=None,
            help="WEIGHTING: Set galaxy catalog weighting"),
        Option("-c", "--completion", metavar="COMPLETENESS", default=None,
            help="COMPLETENESS: Set galaxy catalog completion function."),
        Option("-r", "--counterpart_ra", metavar="RA", default='0.0',
            help="RA: Right ascension of counterpart"),
        Option("-o", "--counterpart_dec", metavar="DEC", default='0.0',
            help="DEC: Declination of counterpart"),
        Option("-j", "--counterpart_vel", metavar="VELOCITY", default='0.',
            help="VELOCITY: Peculiar velocity of counterpart"),
        Option("-i", "--skymap", metavar="SKYMAP", default='200.0',
            help="SKYMAP: LALinference 3D skymap file in format (.fits)"),
        Option("-s", "--posterior_samples", metavar="SAMPLES", default=None,
            help="SAMPLES: LALinference posterior samples file in format (.dat or hdf5)"),
        Option("-z", "--z_max", metavar="ZMAX", default='1.0',
            help="ZMAX: Maximal detectable redshift"),
        Option("-a", "--antenna_network", metavar="ANTENNA", default=None,
            help="ANTENNA: Network antenna power pattern"),
        Option("-p", "--posterior", metavar="POSTERIOR", default=None,
            help="POSTERIOR: Previous H0 posterior as a function of H0 bin")
        #Option("-hc", "--helio-cmb-conv", metavar="REDSHIFT_FRAME", default=False,
            #help="REDSHIFT_FRAME: Convert redshift from heliocentric to cmb frame") #Will implement this conversion to galaxy class
    ])
opts, args = parser.parse_args()

# Check for missing required arguments
missing = []
for option in parser.option_list:
    if 'required' in option.help and eval('opts.' + option.dest) == None:
        missing.extend(option._long_opts)
if len(missing) > 0:
    parser.error('Missing required options: {0}'.format(str(missing)))

print 'Selected method is:', opts.method

if opts.method == 'counterpart':
    use_counterpart = 1
    counterpart_ra = float(opts.counterpart_ra)
    counterpart_dec = float(opts.counterpart_dec)
    counterpart_vel = float(opts.counterpart_vel)

if opts.method == 'statistical' or 'pencil_beam': 
	use_counterpart = 0
	galaxy_catalog = opts.galaxy_catalog
	galaxy_weighting = opts.galaxy_weighting

	if opts.posterior_samples == 'samples':
		posterior_samples = opts.posterior_samples
		#load samples...
	if opts.skymap == 'skymap':
		skymap = opts.skymap
		#load skymap...

if opts.completion == True:
	completion = 1
else:
	completion = 0

if opts.galaxy_weighting == True:
	galaxy_weighting = 1
else:
	galaxy_weighting = 0

# Set command line arguments
min_h0 = float(opts.min_h0)
max_h0 = float(opts.max_h0)
bins_h0 = float(opts.bins_h0)

max_dist = float(opts.max_dist)
min_dist = float(opts.min_dist)
bins_dist = float(opts.bins_dist)

z_max = float(opts.z_max)
antenna_network = opts.antenna_network

options_string = opts.method

hzero = np.linspace(min_h0, max_h0, bins_h0)

import gwcosmo

def main():
    "Compute P(H0)"

    ##Load glade catalog...
    #catalog = gwcosmo.catalog.galaxyCatalog()
    #catalog.load_glade_catalog()

    # load mdc catalogs... version = ['1.0','2.1','3.1']
    catalog = gwcosmo.catalog.galaxyCatalog()
    catalog.load_mdc_catalog(version='1.0')
    
    samples = gwcosmo.posterior_samples.posterior_samples()
    samples.load_posterior_samples()
    # TODO: get mth from galaxy catalogue, rather than by hardcoding it in
    mth = 18.0 # as a test - not true for MDC v1

    #some_galaxy = catalog.get_galaxy(1000)
    #ra = some_galaxy.ra
    #print ra

    #set up array of luminosity distance values
    dl = np.linspace(opts.min_dist,opts.max_dist,opts.bins_dist)
    
    #set up detection probability for BNSs over the range dl
    dp = gwcosmo.detectionprobability.DetectionProbability(1.35,0.1,1.35,0.1,dl)
    
    me = gwcosmo.master.MasterEquation(catalog,dp)

    print("start px_H0G: {}".format(time.asctime()))
    px_H0G = me.px_H0G(hzero,catalog,samples)
    print("end px_H0G: {}".format(time.asctime()))
    
    plt.figure()
    plt.plot(hzero,px_H0G)
    plt.xlabel('$H_0 (kms^{-1}Mpc^{-1})$')
    plt.ylabel('$p(x|H_0,G)$ (unnormalised)')
    plt.savefig('px_H0G.png')
    
    print("start pD_H0G: {}".format(time.asctime()))
    pdet_ingal = me.pD_H0G(hzero,catalog,dp)
    print("end pD_H0G: {}".format(time.asctime()))
    
    plt.figure()
    plt.plot(hzero,pdet_ingal)
    plt.xlabel('$H_0 (kms^{-1}Mpc^{-1})$')
    plt.ylabel('$p(D|H_0,G)$ (unnormalised)')
    plt.savefig('pD_H0G.png')
    
    print("start pG_H0D: {}".format(time.asctime()))
    pgal = me.pG_H0D(hzero,mth,dp)
    print("end pG_H0D: {}".format(time.asctime()))
    
    pngal = me.pnG_H0D(hzero,pgal)
    
    plt.figure()
    plt.plot(hzero,pgal,label='$p(G|H_0,D)$')
    plt.plot(hzero,pngal,label='$p(\overline{G}|H_0,D)$')
    plt.xlabel('$H_0 (kms^{-1}Mpc^{-1})$')
    plt.ylabel('Probability')
    plt.legend()
    plt.savefig('pG_H0D.png')
    
    print("start pD_H0nG: {}".format(time.asctime()))
    pdet_outgal = me.pD_H0nG(hzero,mth,dp)
    print("end pD_H0nG: {}".format(time.asctime()))
    
    plt.figure()
    plt.plot(hzero,pdet_outgal)
    plt.xlabel('$H_0 (kms^{-1}Mpc^{-1})$')
    plt.ylabel('$p(D|H_0,\overline{G})$ (unnormalised)')
    plt.savefig('pD_H0nG.png')
    
    print("start pD_H0nG: {}".format(time.asctime()))
    pH0 = me.pH0_D(hzero,dp,prior='jeffreys')
    print("end pD_H0nG: {}".format(time.asctime()))
    
    plt.figure()
    plt.plot(hzero,pH0)
    plt.xlabel('$H_0 (kms^{-1}Mpc^{-1})$')
    plt.ylabel('$p(H_0|D)$ (unnormalised)')
    plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
    plt.savefig('pH0_D.png')
    

    #posterior_file = "posterior_" + options_string
    #np.savez(posterior_file + options_string + '.npz', hzero)

    return 0

if __name__ == "__main__":
    main()
