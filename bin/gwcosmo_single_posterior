#!/usr/bin/env python
"""
This script computes posterior on H0 using a single gravitational wave event 
and an electromagnetic counterpart.

Ignacio Magana, Rachel Gray, Ankan Sur
"""
# System imports
import pkg_resources
import os
import sys
from optparse import Option, OptionParser
import pickle
import multiprocessing as mp

#Global Imports
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
matplotlib.rcParams['font.family']= 'Times New Roman'
matplotlib.rcParams['font.sans-serif']= ['Bitstream Vera Sans']
matplotlib.rcParams['text.usetex']= True
matplotlib.rcParams['mathtext.fontset']= 'stixsans'

import seaborn as sns
sns.set_context('paper')
sns.set_style('ticks')
sns.set_palette('colorblind')

import numpy as np

import gwcosmo
from gwcosmo.utilities.posterior_utilities import confidence_interval
from gwcosmo.utilities.redshift_utilities import zhelio_to_zcmb
from gwcosmo.utilities.standard_cosmology import *
from gwcosmo.utilities.schechter_params import *
from gwcosmo.utilities.schechter_function import *

import astropy.constants as const
speed_of_light = const.c.to('km/s').value
data_path = pkg_resources.resource_filename('gwcosmo', 'data/')

def str2bool(v):
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')

# Command line options
parser = OptionParser(
    description = __doc__,
    usage = "%prog [options]",
    option_list = [
        Option("--method", default=None,
            help="counterpart, statistical, population (required)"),
        Option("--min_H0", default='20.0', type=float,
            help="Minimum value of H0"),
        Option("--max_H0", default='200.0', type=float,
            help="Maximum value of H0"),
        Option("--bins_H0", default='200', type=int,
            help="Number of H0 bins"),
        Option("--posterior_samples", default=None,
            help="Path to LALinference posterior samples file in format (.dat or hdf5)"),
        Option("--posterior_samples_field", default=None,
            help="Internal field of the posterior samples file, e.g. h5 or json field"),
        Option("--skymap", default=None,
            help="Path to LALinference 3D skymap file in format (.fits or fits.gz)"),
        Option("--Pdet", default=None,
            help="Path to precomputed probability of detection pickle"),
        Option("--galaxy_catalog", default=None,
            help="Path to galaxy catalogue in format (hdf5)"),
        Option("--galaxy_weighting", default='True',
            help="Weight potential host galaxies by luminosity? (Default=True)"),
        Option("--catalog_band", default='B', type=str,
            help = "Observation band of galaxy catalog (B,K,u,g,r,i,z) (must be compatible with the catalogue provided)"),
        Option("--assume_complete_catalog", default='False',
            help="Assume a complete catalog? (Default=False)"),
        Option("--redshift_uncertainty", default='True',
            help="Marginalise over redshift uncertainties (default=True)"),
        Option("--counterpart_ra", default=None,
            help="Right ascension of counterpart"),
        Option("--counterpart_dec", default=None,
            help="Declination of counterpart"),
        Option("--counterpart_z", default=None,
            help="Redshift of counterpart (in CMB frame)"),
        Option("--counterpart_sigmaz", default=None,
            help="Uncertainty of counterpart in redshift"),
        Option("--counterpart_v", default=None,
            help="Recessional velocity of counterpart in km/sec (in CMB frame)"),
        Option("--counterpart_sigmav", default=None,
            help="Uncertainty of counterpart in km/sec"),
        Option("--redshift_evolution", default='False',
            help="Allow GW host probability to evolve with redshift? (Default=False)"),
        Option("--Lambda", default='3.0', type=float,
            help="Set rate evolution parameter Lambda"),
        Option("--Kcorrections", default='False',
            help="Apply K-corrections."),
        Option("--reweight_posterior_samples", default='False',
            help="Reweight posterior samples with the same priors used to calculate the selection effects."),
        Option("--zmax", default='10.0', type=float,
            help="Upper redshift limit for integrals (default=10)"),
        Option("--zcut", default=None,
            help="Hard redshift cut to apply to the galaxy catalogue (default=None)"),
        Option("--mth", default=None,
            help="Override the apparent magnitude threshold of the catalogue, if provided (default=None)"),
        Option("--nside", default='64', type=int,
            help="skymap nside choice for reading in galaxies from the overlap of catalogue and skymap (default=64)"),
        Option("--sky_area", default='0.9999', type=float,
            help="contour boundary for galaxy catalogue method (default=0.9999)"), 
        Option("--outputfile", default='Posterior',
            help="Name of output file")
    ])
opts, args = parser.parse_args()
print(opts)

# Check for missing required arguments
missing = []
for option in parser.option_list:
    if 'required' in option.help and eval('opts.' + option.dest) == None:
        missing.extend(option._long_opts)
if len(missing) > 0:
    parser.error('Missing required options: {0}'.format(str(missing)))
    
print('Selected method is:', opts.method)

if (opts.posterior_samples is None):
    parser.error('Currently all methods are implemented to work with posterior samples. \
                  We are working to add skymap compatability as soon as possible.')

if opts.Pdet is None:
    parser.error('Provide a precomputed probability of detection.')

if opts.posterior_samples is not None:
    posterior_samples = str(opts.posterior_samples)

if opts.posterior_samples_field is not None:
    posterior_samples_field = str(opts.posterior_samples_field)


# Set command line arguments
min_H0 = float(opts.min_H0)
max_H0 = float(opts.max_H0)
bins_H0 = int(opts.bins_H0)


redshift_evolution = str2bool(opts.redshift_evolution)
Lambda = float(opts.Lambda)
reweight_samples = str2bool(opts.reweight_posterior_samples)
outputfile = str(opts.outputfile)
pdet_path = str(opts.Pdet)
zmax = float(opts.zmax)

"Compute P(H0)"
H0 = np.linspace(min_H0, max_H0, bins_H0)
dH0 = H0[1] - H0[0]

pdet = pickle.load(open(pdet_path, 'rb'))
mass_distribution = pdet.mass_distribution
mass_slope = pdet.alpha
psd = pdet.asd
Mmin = pdet.Mmin
Mmax = pdet.Mmax
network_snr_threshold = pdet.snr_threshold

print('Loading precomputed pdet with a {} mass distribution at {} sensitivity assuming an SNR threshold of {}.'.format(mass_distribution, psd, network_snr_threshold))
if mass_distribution == 'BBH-powerlaw':
    print('Mass distribution parameters: alpha=-{}, Mmin={}, Mmax={}'.format(mass_slope, Mmin, Mmax))

Omega_m = pdet.Omega_m
linear_cosmo = pdet.linear
zprior = redshift_prior(Omega_m=Omega_m, linear=linear_cosmo)
cosmo = fast_cosmology(Omega_m=Omega_m, linear=linear_cosmo)
if redshift_evolution:
    ps_z = gwcosmo.gwcosmo.RedshiftEvolution()
else:
    ps_z = gwcosmo.gwcosmo.RedshiftNonEvolution()

print('Setting up a cosmology with Omega_m={}'.format(Omega_m))

# Once different methods can run with just skymap (instead of samples) this will need moving
if opts.posterior_samples is not None:
    print("Loading posterior samples.")
    samples = gwcosmo.likelihood.posterior_samples.posterior_samples(posterior_samples,path=posterior_samples_field)
    
    px_zH0 = gwcosmo.likelihood.posterior_samples.make_px_function(samples, H0, reweight_samples=reweight_samples, mass_distribution=mass_distribution, alpha=mass_slope, mmin=Mmin, mmax=Mmax)

if opts.method == 'counterpart':
    ### This method currently only works with posterior samples which are already 
    ### marginalised along the LOS of the counterpart.
    ### TODO: get this working for regular posterior samples.
    ### TODO: get this working with a skymap and no samples.
    if (opts.counterpart_z is None and opts.counterpart_v is None):
        parser.error('Provide either counterpart redshift or recessional velocity.')
        
    if (opts.counterpart_z is not None and opts.counterpart_v is not None):
        print('Both counterpart redshift and recessional velocity provided. Using recessional velocity.')
        
    if (opts.posterior_samples is not None and opts.skymap is not None):
        print('Both posterior samples and skymap provided. Using posterior samples.')
        
    if opts.counterpart_ra is not None:
        counterpart_ra = float(opts.counterpart_ra)
    if opts.counterpart_dec is not None:
        counterpart_dec = float(opts.counterpart_dec)
    if opts.counterpart_z is not None:
        counterpart_z = float(opts.counterpart_z)
    if opts.counterpart_sigmaz is not None:
        counterpart_sigmaz = float(opts.counterpart_sigmaz)
    if opts.counterpart_v is not None:
        counterpart_v = float(opts.counterpart_v)
        counterpart_z = counterpart_v/speed_of_light
    if opts.counterpart_sigmav is not None:
        counterpart_sigmav = float(opts.counterpart_sigmav)
        counterpart_sigmaz = counterpart_sigmav/speed_of_light

    me = gwcosmo.gwcosmo.DirectCounterpartLikelihood(counterpart_z,counterpart_sigmaz,px_zH0,pdet.pD_zH0_eval,zprior,ps_z,zmax=zmax)
    
if opts.method == 'population':

    me = gwcosmo.gwcosmo.EmptyCatalogLikelihood(px_zH0,pdet.pD_zH0_eval,zprior,ps_z,zmax=zmax)

if opts.method == 'statistical':
    if (opts.galaxy_catalog is None):
        parser.error('Provide a galaxy catalogue.')
        
    if (opts.skymap is None):
        parser.error('Provide a gravitational wave skymap')
        
    skymap_path = str(opts.skymap)
    catalog_path = str(opts.galaxy_catalog)
    band = str(opts.catalog_band)
    Kcorr = str2bool(opts.Kcorrections)
    zuncert = str2bool(opts.redshift_uncertainty)
    galaxy_weighting = str2bool(opts.galaxy_weighting)
    nside = int(opts.nside)
    sky_area = float(opts.sky_area)
    complete_catalog = str2bool(opts.assume_complete_catalog)
    if opts.mth is not None:
        mth = float(opts.mth)
    else:
        mth = None
    if opts.zcut is not None:
        zcut = float(opts.zcut)
    else:
        zcut = None
    
    skymap = gwcosmo.likelihood.skymap.skymap(skymap_path)
    
    catalog = gwcosmo.prior.catalog.galaxyCatalog(catalog_file=catalog_path,skymap=skymap,band=band,thresh=sky_area,Kcorr=Kcorr,nside=nside)
    sp = SchechterParams(catalog.band)
    
    p_M = SchechterMagFunction(Mstar_obs=sp.Mstar,alpha=sp.alpha)
    if galaxy_weighting:
        ps_M = gwcosmo.gwcosmo.LuminosityWeighting()
    else:
        ps_M = gwcosmo.gwcosmo.UniformWeighting()

    me = gwcosmo.gwcosmo.WholeSkyGalaxyCatalogLikelihood(catalog, skymap, band, cosmo, px_zH0, pdet.pD_zH0_eval, zprior, ps_z, p_M, ps_M, Kcorr=Kcorr, mth=mth, zcut=zcut, zmax=zmax,zuncert=zuncert, complete_catalog=complete_catalog)

likelihood = me(H0,Lambda=Lambda)
pxG, pDG, pG, pxB, pDB, pB, pxO, pDO, pO = me.return_components()

prior_uniform = gwcosmo.prior.priors.pH0(H0,prior='uniform')
posterior_uniform = prior_uniform*likelihood
prior_log = gwcosmo.prior.priors.pH0(H0,prior='log')
posterior_log= prior_log*likelihood

prior_uniform_norm = prior_uniform/np.sum(prior_uniform*dH0)
posterior_uniform_norm = posterior_uniform/np.sum(posterior_uniform*dH0)
prior_log_norm = prior_log/np.sum(prior_log*dH0)
posterior_log_norm = posterior_log/np.sum(posterior_log*dH0)

np.savez(outputfile+'.npz',[H0,likelihood,posterior_uniform_norm,posterior_log_norm,opts])
np.savez(outputfile+'_likelihood_breakdown.npz',[H0, likelihood, pxG, pDG, pG, pxB, pDB, pB, pxO, pDO, pO])

print("Uniform Prior")
confidence_uniform = confidence_interval(posterior_uniform_norm,H0,level=0.683)
MAP_uniform = confidence_uniform.map
a_uniform = confidence_uniform.lower_level
b_uniform = confidence_uniform.upper_level
print('H0 = %.0f + %.0f - %.0f (MAP and 68.3 percent HDI)' %(MAP_uniform,b_uniform-MAP_uniform,MAP_uniform-a_uniform))

print("Log Prior")
confidence_log = confidence_interval(posterior_log_norm,H0,level=0.683)
MAP_log = confidence_log.map
a_log = confidence_log.lower_level
b_log = confidence_log.upper_level
print('H0 = %.0f + %.0f - %.0f (MAP and 68.3 percent HDI)' %(MAP_log,b_log-MAP_log,MAP_log-a_log))

ymin = 0
ymax = 1.1*max(posterior_log_norm)
planck_h = 0.6774*100
sigma_planck_h = 0.0062*100
riess_h = 0.7324*100
sigma_riess_h = 0.0174*100

c=sns.color_palette('colorblind')
plt.figure()
plt.axvline(planck_h,label='Planck',color=c[4])
plt.fill_betweenx([ymin,ymax],planck_h-2*sigma_planck_h,planck_h+2*sigma_planck_h,color=c[4],alpha=0.2)
plt.axvline(riess_h,label='SH0ES',color=c[2])
plt.fill_betweenx([ymin,ymax],riess_h-2*sigma_riess_h,riess_h+2*sigma_riess_h,color=c[2],alpha=0.2)
plt.axvline(70,ls='--', color='k',alpha=0.8, label = r'$H_0 = 70$ (km s$^{-1}$ Mpc$^{-1}$)')
plt.plot(H0,posterior_uniform_norm, linewidth = 3.0, label='Posterior (Uniform)',c=c[0])
plt.axvline(a_uniform,ls='--',c=c[0])
plt.axvline(b_uniform,ls='--',c=c[0])
plt.plot(H0,posterior_log_norm,linewidth = 3.0, label='Posterior (Log)',c=c[1])
plt.axvline(a_log,ls='--',c=c[1])
plt.axvline(b_log,ls='--',c=c[1])
plt.plot(H0,prior_uniform_norm,ls=':', linewidth = 3.0, label='Prior (Uniform)',c=c[0],alpha=0.6)
plt.plot(H0,prior_log_norm,ls=':', linewidth = 3.0, label='Prior (Log)',c=c[1],alpha=0.6)
plt.xlim(min_H0,max_H0)
plt.ylim(ymin,ymax)
plt.xticks(fontsize=14)
plt.yticks(fontsize=14)
plt.xlabel(r'$H_0$ (km s$^{-1}$ Mpc$^{-1}$)',fontsize=16)
plt.ylabel(r'$p(H_0)$ (km$^{-1}$ s Mpc)', fontsize=16)
plt.legend(loc='upper right',fontsize=10)
plt.tight_layout()
plt.savefig(outputfile+'.pdf',dpi=200)
