#!/usr/bin/python

"""
This script computes H0 as a function of H0 bins.
"""
__author__ = "Ignacio Magana Hernandez <ignacio.magana@ligo.org>"

# System imports
import os
import sys
from optparse import Option, OptionParser

#Global Imports
import numpy as np
import matplotlib 
matplotlib.use('agg')
import matplotlib.pyplot as plt
from scipy.integrate import quad, dblquad

import time

# Command line options
parser = OptionParser(
    description = __doc__,
    usage = "%prog [options]",
    option_list = [
        Option("-m", "--method", metavar="METHOD", default='counterpart',
            help="METHOD: Select counterpart/statistical/pencil_beam method (required)"),
        Option("-u", "--min_h0", metavar="MINH0", default='10.0',
            help="MINH0: Set minimum value of H0 Posterior"),
        Option("-v", "--max_h0", metavar="MAXH0", default='220.0',
            help="MAXH0: Set maximum value of H0 Posterior"),
        Option("-x", "--bins_h0", metavar="BINSH0", default='50',
            help="BINSH0: Set number of H0 Posterior bins"),
        Option("-d", "--min_dist", metavar="MINDIST", default='0.1', type=float,
            help="MINDIST: Set minimum value of luminosity distance"),
        Option("-e", "--max_dist", metavar="MAXDIST", default='400.0', type=float,
            help="MAXDIST: Set maximum value of luminosity distance"),
        Option("-f", "--bins_dist", metavar="BINSDIST", default='50', type=int,
            help="BINSDIST: Set number of luminosity distance bins"),
        Option("-g", "--galaxy_catalog", metavar="CATALOG", default=None,
            help="CATALOG: Galaxy catalog file in hdf5 format"),
        Option("-w", "--galaxy_weighting", metavar="WEIGHTING", default=None,
            help="WEIGHTING: Set galaxy catalog weighting"),
        Option("-c", "--completion", metavar="COMPLETENESS", default=None,
            help="COMPLETENESS: Set galaxy catalog completion function."),
        Option("-r", "--counterpart_ra", metavar="RA", default='0.0',
            help="RA: Right ascension of counterpart"),
        Option("-o", "--counterpart_dec", metavar="DEC", default='0.0',
            help="DEC: Declination of counterpart"),
        Option("-j", "--counterpart_vel", metavar="VELOCITY", default='0.',
            help="VELOCITY: Peculiar velocity of counterpart"),
        Option("-i", "--skymap", metavar="SKYMAP", default='200.0',
            help="SKYMAP: LALinference 3D skymap file in format (.fits)"),
        Option("-s", "--posterior_samples", metavar="SAMPLES", default=None,
            help="SAMPLES: LALinference posterior samples file in format (.dat or hdf5)"),
        Option("-z", "--z_max", metavar="ZMAX", default='1.0',
            help="ZMAX: Maximal detectable redshift"),
        Option("-a", "--antenna_network", metavar="ANTENNA", default=None,
            help="ANTENNA: Network antenna power pattern"),
        Option("-p", "--posterior", metavar="POSTERIOR", default=None,
            help="POSTERIOR: Previous H0 posterior as a function of H0 bin")
        #Option("-hc", "--helio-cmb-conv", metavar="REDSHIFT_FRAME", default=False,
            #help="REDSHIFT_FRAME: Convert redshift from heliocentric to cmb frame") #Will implement this conversion to galaxy class
    ])
opts, args = parser.parse_args()

# Check for missing required arguments
missing = []
for option in parser.option_list:
    if 'required' in option.help and eval('opts.' + option.dest) == None:
        missing.extend(option._long_opts)
if len(missing) > 0:
    parser.error('Missing required options: {0}'.format(str(missing)))

print 'Selected method is:', opts.method

if opts.method == 'counterpart':
    use_counterpart = 1
    counterpart_ra = float(opts.counterpart_ra)
    counterpart_dec = float(opts.counterpart_dec)
    counterpart_vel = float(opts.counterpart_vel)

if opts.method == 'statistical' or 'pencil_beam': 
	use_counterpart = 0
	galaxy_catalog = opts.galaxy_catalog
	galaxy_weighting = opts.galaxy_weighting

	if opts.posterior_samples == 'samples':
		posterior_samples = opts.posterior_samples
		#load samples...
	if opts.skymap == 'skymap':
		skymap = opts.skymap
		#load skymap...

if opts.completion == True:
	completion = 1
else:
	completion = 0

if opts.galaxy_weighting == True:
	galaxy_weighting = 1
else:
	galaxy_weighting = 0

# Set command line arguments
min_h0 = float(opts.min_h0)
max_h0 = float(opts.max_h0)
bins_h0 = float(opts.bins_h0)

max_dist = float(opts.max_dist)
min_dist = float(opts.min_dist)
bins_dist = float(opts.bins_dist)

z_max = float(opts.z_max)
antenna_network = opts.antenna_network

options_string = opts.method

hzero = np.linspace(min_h0, max_h0, bins_h0)



def px_H0G(hzero,galaxy_catalogue,posterior_samples):
    """
    The likelihood of the GW data given the source is in the catalogue and given H0 (will eventually include luminosity weighting). 
    
    Takes an array of H0 values, a galaxy catalogue, and posterior samples/skymap for 1 event.
    Creates a likelihood using the samples/skymap.
    Evaluates the likelihood at the location of every galaxy in 99% sky area of event.
    Sums over these values.
    Returns an array of values corresponding to different values of H0.
    """
    return 1



def pD_H0G(hzero,galaxy_catalog,pdet):
    """
    The normalising factor for px_H0G.
    
    Takes an array of H0 values and a galaxy catalogue.
    Evaluates detection probability at the location of every galaxy in the catalogue.
    Sums over these values.
    Returns an array of values corresponding to different values of H0.
    """  
    nGal = galaxy_catalog.nGal()
    den = np.zeros(len(hzero))       
    for i in range(nGal):
        gal = galaxy_catalog.get_galaxy(i)
        z = gal.z
        den += pdet.pD_dl_eval(gwcosmo.standard_cosmology.dl_zH0(z,hzero))
    return den



def pG_H0D(hzero,mth,pdet):
    """
    The probability that the host galaxy is in the catalogue given detection and H0.
    
    Takes an array of H0 values, and the apparent magnitude threshold of the galaxy catalogue.
    Integrates p(M|H0)*p(z)*p(D|dL(z,H0)) over z and M, incorporating mth into limits.  Should be internally normalised.
    Returns an array of probabilities corresponding to different H0s.
    """  
    # Warning - this integral misbehaves for small values of H0 (<25 kms-1Mpc-1).  TODO: fix this.
    num = np.zeros(len(hzero)) 
    den = np.zeros(len(hzero))
    
    # TODO: vectorize this if possible
    for i in range(len(hzero)):
        
        def I(z,M):
            return gwcosmo.schechter_function.SchechterMagFunction(H0=hzero[i])(M)*pdet.pD_dl_eval(gwcosmo.standard_cosmology.dl_zH0(z,hzero[i]))*gwcosmo.prior.basic.pz_nG(z)
        
        # Mmin and Mmax currently corresponding to 10L* and 0.001L* respectively, to correspond with MDC
        # Will want to change in future.
        # TODO: test how sensitive this result is to changing Mmin and Mmax.
        Mmin = gwcosmo.schechter_function.M_Mobs(hzero[i],-22.96)
        Mmax = gwcosmo.schechter_function.M_Mobs(hzero[i],-12.96)
        
        # TODO: change zmax = 6.0 to a reasonably high limit
        num[i] = dblquad(I,Mmin,Mmax,lambda x: 0,lambda x: gwcosmo.standard_cosmology.z_dlH0(gwcosmo.standard_cosmology.dl_mM(mth,x),hzero[i]),epsabs=0,epsrel=1.49e-4)[0]
        den[i] = dblquad(I,Mmin,Mmax,lambda x: 0,lambda x: 6.0,epsabs=0,epsrel=1.49e-4)[0]
        #print("{}: Calculated for H0 {}/{}".format(time.asctime(),i+1,len(hzero)))
    
    return num/den    



def pnG_H0D(hzero,pG):
    """
    The probability that a galaxy is not in the catalogue given detection and H0
    
    Returns the complement of pG_H0D.
    """
    return 1.0 - pG


   
    
def px_H0nG(hzero,mth,posterior_samples):
    """
    The likelihood of the GW data given not in the catalogue and H0
    
    Takes an array of H0 values, an apparent magnitude threshold, and posterior samples/skymap for 1 event.
    Creates a likelihood using the samples/skymap: p(x|dL,Omega).
    Integrates p(x|dL(z,H0))*p(z)*p(M|H0) over z and M, incorporating mth into limits.
    Returns an array of values corresponding to different values of H0.
    """
    return 1



def pD_H0nG(hzero,mth,pdet):
    """
    Normalising factor for px_H0nG
    
    Takes an array of H0 values and an apparent magnitude threshold.
    Integrates p(D|dL(z,H0))*p(z)*p(M|H0) over z and M, incorporating mth into limits.
    Returns an array of values corresponding to different values of H0.
    """  
    # TODO: same fixes as for pG_H0D 
    den = np.zeros(len(hzero))
    
    for i in range(len(hzero)):
        
        def I(z,M):
            return gwcosmo.schechter_function.SchechterMagFunction(H0=hzero[i])(M)*pdet.pD_dl_eval(gwcosmo.standard_cosmology.dl_zH0(z,hzero[i]))*gwcosmo.prior.basic.pz_nG(z)
        
        Mmin = gwcosmo.schechter_function.M_Mobs(hzero[i],-22.96)
        Mmax = gwcosmo.schechter_function.M_Mobs(hzero[i],-12.96)
        
        den[i] = dblquad(I,Mmin,Mmax,lambda x: gwcosmo.standard_cosmology.z_dlH0(gwcosmo.standard_cosmology.dl_mM(mth,x),hzero[i]),lambda x: 6.0,epsabs=0,epsrel=1.49e-4)[0]
        #print("{}: Calculated for H0 {}/{}".format(time.asctime(),i+1,len(hzero)))
    
    return den



def pH0_D(hzero,pdet,prior='uniform'):
    """
    The prior probability of H0 given a detection
    
    Takes an array of H0 values and a choice of prior.
    Integrates p(D|dL(z,H0))*p(z) over z
    Returns an array of values corresponding to different values of H0.
    """
    pH0 = np.zeros(len(hzero))
    for i in range(len(hzero)):
        def I(z):
            return pdet.pD_dl_eval(gwcosmo.standard_cosmology.dl_zH0(z,hzero[i]))*gwcosmo.prior.basic.pz_nG(z)
   
        pH0[i] = quad(I,0,6.0,epsabs=0,epsrel=1.49e-4)[0]
            
    if prior == 'jeffreys':
        return pH0/hzero  
    else:
        return pH0

import gwcosmo

def main():
    "Compute P(H0)"

    ##Load glade catalog...
    #catalog = gwcosmo.catalog.galaxyCatalog()
    #catalog.load_glade_catalog()

    # load mdc catalogs... version = ['1.0','2.1','3.1']
    catalog = gwcosmo.catalog.galaxyCatalog()
    catalog.load_mdc_catalog(version='1.0')
    
    # TODO: get mth from galaxy catalogue, rather than by hardcoding it in
    mth = 18.0 # as a test - not true for MDC v1

    #some_galaxy = catalog.get_galaxy(1000)
    #ra = some_galaxy.ra
    #print ra

    #set up array of luminosity distance values
    dl = np.linspace(opts.min_dist,opts.max_dist,opts.bins_dist)
    
    #set up detection probability for BNSs over the range dl
    dp = gwcosmo.detectionprobability.DetectionProbability(1.35,0.1,1.35,0.1,dl)
    
    print("start pD_H0G: {}".format(time.asctime()))
    pdet_ingal = pD_H0G(hzero,catalog,dp)
    print("end pD_H0G: {}".format(time.asctime()))
    
    plt.figure()
    plt.plot(hzero,pdet_ingal)
    plt.xlabel('$H_0 (kms^{-1}Mpc^{-1})$')
    plt.ylabel('$p(D|H_0,G)$ (unnormalised)')
    plt.savefig('pD_H0G.png')
    
    print("start pG_H0D: {}".format(time.asctime()))
    pgal = pG_H0D(hzero,mth,dp)
    print("end pG_H0D: {}".format(time.asctime()))
    
    pngal = pnG_H0D(hzero,pgal)
    
    plt.figure()
    plt.plot(hzero,pgal,label='$p(G|H_0,D)$')
    plt.plot(hzero,pngal,label='$p(\overline{G}|H_0,D)$')
    plt.xlabel('$H_0 (kms^{-1}Mpc^{-1})$')
    plt.ylabel('Probability')
    plt.legend()
    plt.savefig('pG_H0D.png')
    
    print("start pD_H0nG: {}".format(time.asctime()))
    pdet_outgal = pD_H0nG(hzero,mth,dp)
    print("end pD_H0nG: {}".format(time.asctime()))
    
    plt.figure()
    plt.plot(hzero,pdet_outgal)
    plt.xlabel('$H_0 (kms^{-1}Mpc^{-1})$')
    plt.ylabel('$p(D|H_0,\overline{G})$ (unnormalised)')
    plt.savefig('pD_H0nG.png')
    
    print("start pD_H0nG: {}".format(time.asctime()))
    pH0 = pH0_D(hzero,dp,prior='jeffreys')
    print("end pD_H0nG: {}".format(time.asctime()))
    
    plt.figure()
    plt.plot(hzero,pH0)
    plt.xlabel('$H_0 (kms^{-1}Mpc^{-1})$')
    plt.ylabel('$p(H_0|D)$ (unnormalised)')
    plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
    plt.savefig('pH0_D.png')
    

    #posterior_file = "posterior_" + options_string
    #np.savez(posterior_file + options_string + '.npz', hzero)

    return 0

if __name__ == "__main__":
    main()
