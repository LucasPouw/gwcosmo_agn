#!/usr/bin/env python
"""
This script computes H0 as a function of H0 bins.
Ignacio Magana, Rachel Gray, Ankan Sur
"""
# System imports
import os
import sys
from optparse import Option, OptionParser

#Global Imports
import matplotlib 
matplotlib.use('agg')
import matplotlib.pyplot as plt
matplotlib.rcParams['font.family']= 'Times New Roman'
matplotlib.rcParams['font.sans-serif']= ['Bitstream Vera Sans']
matplotlib.rcParams['text.usetex']= True
matplotlib.rcParams['mathtext.fontset']= 'stixsans'

import seaborn as sns
sns.set_context('paper')
sns.set_style('ticks')
sns.set_palette('colorblind')

import numpy as np
import gwcosmo

from gwcosmo.utilities.posterior_utilities import confidence_interval

def str2bool(v):
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')

# Command line options
parser = OptionParser(
    description = __doc__,
    usage = "%prog [options]",
    option_list = [
        Option("-m", "--method", metavar="METHOD", default=None,
            help="METHOD: Select counterpart/statistical (required)"),
        Option("-u", "--min_H0", metavar="MINH0", default='30.0', type=float,
            help="MINH0: Set minimum value of H0 Posterior"),
        Option("-v", "--max_H0", metavar="MAXH0", default='200.0', type=float,
            help="MAXH0: Set maximum value of H0 Posterior"),
        Option("-x", "--bins_H0", metavar="BINSH0", default='200', type=int,
            help="BINSH0: Set number of H0 Posterior bins"),
        Option("-k", "--posterior_samples", metavar="SAMPLES", default=None,
            help="SAMPLES: LALinference posterior samples file in format (.dat or hdf5) or use GW170817, GW170814, GW170818"),
        Option("-t", "--mass_distribution", metavar="MASS_DISTRIBUTION", default=None,
            help="MASS_DISTRIBUTION: Choose between BNS or BBH mass distributions for Pdet calculation."),
        Option("-i", "--skymap", metavar="SKYMAP", default=None,
            help="SKYMAP: LALinference 3D skymap file in format (.fits)"),
        Option("-g", "--galaxy_catalog", metavar="GALAXY_CATALOG", default=None,
            help="GALAXY_CATALOG: Load galaxy catalog in pickle format"),
        Option("-j", "--psd", metavar="PSD", default=None,
            help="PSD: Select between 'O1' and 'O2' PSDs, by default we use aLIGO at design sensitivity (default=None)."), 
        Option("-w", "--galaxy_weighting", metavar="WEIGHTING", default='False',
            help="WEIGHTING: Set galaxy catalog weighting"),
        Option("-y", "--weights", metavar="WEIGHTS", default=None,
            help="WEIGHTS: Choose galaxy catalog weight types."),        
        Option("-c", "--completion", metavar="COMPLETENESS", default='False',
            help="COMPLETENESS: Assumes a complete catalog."),
        Option("-a", "--uncertainty", metavar="UNCERTAINTY", default='True',
            help="UNCERTAINTY: Apply redshift uncertainties."),
        Option("-f", "--linear_cosmology", metavar="LINEAR", default='False',
            help="LINEAR: Assume a linear cosmology."),
        Option("-e", "--basic_pdet", metavar="BASIC", default='False',
            help="BASIC: Allow for masses to be redshifted in Pdet using False."),
        Option("-r", "--counterpart_ra", metavar="RA", default=None,
            help="RA: Right ascension of counterpart"),
        Option("-o", "--counterpart_dec", metavar="DEC", default=None,
            help="DEC: Declination of counterpart"),
        Option("-z", "--counterpart_z", metavar="REDSHIFT", default=None,
            help="REDSHIFT: Redshift of counterpart"),
        Option("-d", "--omega_m", metavar="OMEGAM", default='0.308', type=float,
            help="OMEGAM: Set value for omega_m."),
        Option("-s", "--Mstar_obs", metavar="MSTAROBS", default='-20.457', type=float,
            help="MSTAROBS: Set value for Mstar_obs."),
        Option("-l", "--alpha", metavar="ALPHA", default='-1.07', type=float,
            help="ALPHA: Set value for alpha."),
        Option("-n", "--Mmin_obs", metavar="MMINOBS", default='-22.96', type=float,
            help="MMINOBS: Set value for Mmin_obs."),
        Option("-q", "--Mmax_obs", metavar="MMAXOBS", default='-12.96', type=float,
            help="MMAXOBS: Set value for Mmax_obs."),
        Option("--mth", metavar="MTH", default=None,
            help="MTH: Set value for MTH."),
        Option("-b", "--outputfile", metavar="OUTPUTFILE", default='Posterior',
            help="OUTPUTFILE: Name of output file"),
        Option("-p", "--plot", metavar="PLOT", default=None,
            help="PLOT: Plot .npz file")
    ])
opts, args = parser.parse_args()
print(opts)
print(args)

# Check for missing required arguments
missing = []
for option in parser.option_list:
    if 'required' in option.help and eval('opts.' + option.dest) == None:
        missing.extend(option._long_opts)
if len(missing) > 0:
    parser.error('Missing required options: {0}'.format(str(missing)))

print('Selected method is:', opts.method)
if opts.plot is not None:
    filename = str(opts.plot)
    data = np.load(filename)['arr_0']
    H0 = data[0]
    min_H0 = min(H0)
    max_H0 = max(H0)
    dH0 = H0[1]-H0[0]
    prior_uniform = gwcosmo.prior.priors.pH0(H0,prior='uniform')
    prior_log = gwcosmo.prior.priors.pH0(H0,prior='log')
    prior_uniform_norm = prior_uniform/np.sum(prior_uniform*dH0)
    prior_log_norm = prior_log/np.sum(prior_log*dH0)
    posterior_uniform_norm = data[2]
    posterior_log_norm = data[3]
    outputfile = filename[:-4]
    
else:
    if (opts.posterior_samples is None and
        opts.skymap is None):
            parser.error('Provide either posterior samples and skymap.')

    if opts.mass_distribution is None:
            parser.error('Provide a mass distribution to use for Pdet calculation.')

    if opts.galaxy_catalog is None:
        parser.error('The statistical method requires a galaxy catalog. Please provide one.')

    if opts.posterior_samples is not None:
            posterior_samples = str(opts.posterior_samples)
    if opts.skymap is not None:
            skymap = str(opts.skymap)

    if opts.mass_distribution is not None:
            mass_distribution = str(opts.mass_distribution)

    if opts.galaxy_catalog is not None:
        galaxy_catalog = str(opts.galaxy_catalog)

    if opts.method == 'statistical':
        if (str2bool(opts.galaxy_weighting) is True and
        opts.weights is None):
            parser.error('Provide choose galaxy weights: trivial or schechter weights')
        else:
            galaxy_weighting = str2bool(opts.galaxy_weighting)
            weights = str(opts.weights)
        completion = str2bool(opts.completion)

    if opts.method == 'counterpart':
        galaxy_weighting = False
        weights = 'schechter'
        completion = True
        if opts.counterpart_ra is not None:
            counterpart_ra = float(opts.counterpart_ra)
        if opts.counterpart_dec is not None:
            counterpart_dec = float(opts.counterpart_dec)
        if opts.counterpart_z is not None:
            counterpart_z = float(opts.counterpart_z)

    # Set command line arguments
    min_H0 = float(opts.min_H0)
    max_H0 = float(opts.max_H0)
    bins_H0 = float(opts.bins_H0)
    
    uncertainty = str2bool(opts.uncertainty)
    linear = str2bool(opts.linear_cosmology)
    basic = str2bool(opts.basic_pdet)
    omega_m = float(opts.omega_m)
    Mstar_obs=float(opts.Mstar_obs)
    alpha=float(opts.alpha)
    Mmin_obs=float(opts.Mmin_obs)
    Mmax_obs=float(opts.Mmax_obs)
    
    if opts.mth is not None:
        mth = float(opts.mth)
        print(mth)
    else:
        mth = None
    
    if opts.psd is not None:
        psd = str(opts.psd)
        print(psd)
    else:
        psd = None
        print(psd)

    options_string = opts.method
    outputfile = str(opts.outputfile)

    "Compute P(H0)"
    H0 = np.linspace(min_H0, max_H0, bins_H0)
    dH0 = H0[1] - H0[0]
    
    if opts.posterior_samples is not None:
        samples = gwcosmo.likelihood.posterior_samples.posterior_samples()
        if posterior_samples[-4:] == 'hdf5':
            samples.load_posterior_samples_hdf5(posterior_samples)
        if posterior_samples[-3:] == 'hdf':
            samples.load_posterior_samples_hdf(posterior_samples)
        if posterior_samples[-3:] == 'dat':
            samples.load_posterior_samples(posterior_samples)
        skymap3d = None
        if opts.skymap is not None:
            skymap2d = gwcosmo.likelihood.skymap.skymap2d(skymap)
        else:
            skymap2d = None
    else:
        #TODO: Implement 3D skymap here for pixel method
        skymap3d = gwcosmo.likelihood.skymap.skymap(skymap)

    if galaxy_catalog[-2:] == '.p':
        catalog = gwcosmo.prior.catalog.galaxyCatalog(catalog_file=galaxy_catalog)
    else:
        print('Not a compatible catalog.')

    if catalog.skypatch['allsky'] is not None:
        allsky = False
        radeclims = catalog.skypatch['allsky']
    else:
        allsky = True
        radeclims = None

    if opts.method == 'counterpart':
        counterpart = gwcosmo.prior.catalog.galaxyCatalog()
        if (opts.counterpart_ra is None or
            opts.counterpart_dec is None or
            opts.counterpart_z is None):
            parser.error('The counterpart method requires the ra, dec, and z of the galaxy.')
        else:
            counterpart.get_galaxy(0).ra = counterpart_ra*np.pi/180.
            counterpart.get_galaxy(0).dec = counterpart_dec*np.pi/180.
            counterpart.get_galaxy(0).z = counterpart_z
            counterpart.get_galaxy(0).sigmaz = 6.671e-4 #200/c
    else:
        counterpart = None

    # compute likelihood
    me = gwcosmo.gwcosmo.gwcosmoLikelihood(mass_distribution,catalog,psd,Omega_m=omega_m,linear=linear,weighted=galaxy_weighting,weights=weights,whole_cat=allsky,radec_lim=radeclims,uncertainty=uncertainty,basic=basic,Mstar_obs=Mstar_obs,alpha=alpha,Mmin_obs=Mmin_obs,Mmax_obs=Mmax_obs,mth=mth)
    likelihood = me.likelihood(H0,samples,skymap2d=skymap2d,EM_counterpart=counterpart,complete=completion,counterpart_case='direct')
    prior_uniform = gwcosmo.prior.priors.pH0(H0,prior='uniform')
    posterior_uniform = prior_uniform*likelihood
    prior_log = gwcosmo.prior.priors.pH0(H0,prior='log')
    posterior_log= prior_log*likelihood
    
    prior_uniform_norm = prior_uniform/np.sum(prior_uniform*dH0)
    posterior_uniform_norm = posterior_uniform/np.sum(posterior_uniform*dH0)
    prior_log_norm = prior_log/np.sum(prior_log*dH0)
    posterior_log_norm = posterior_log/np.sum(posterior_log*dH0)
    
    np.savez(outputfile+'.npz',[H0,likelihood,posterior_uniform_norm,posterior_log_norm,opts])

print("Uniform Prior")
MAP_uniform, a_uniform, b_uniform = confidence_interval(posterior_uniform_norm,H0,level=0.683)
print("Log Prior")
MAP_log, a_log, b_log = confidence_interval(posterior_log_norm,H0,level=0.683)

ymin = 0
ymax = 1.1*max(posterior_log_norm)
planck_h = 0.6774*100
sigma_planck_h = 0.0062*100
riess_h = 0.7324*100
sigma_riess_h = 0.0174*100

c=sns.color_palette('colorblind')
plt.figure()
plt.axvline(planck_h,label='Planck',color=c[4])
plt.fill_betweenx([ymin,ymax],planck_h-2*sigma_planck_h,planck_h+2*sigma_planck_h,color=c[4],alpha=0.2)
plt.axvline(riess_h,label='SH0ES',color=c[2])
plt.fill_betweenx([ymin,ymax],riess_h-2*sigma_riess_h,riess_h+2*sigma_riess_h,color=c[2],alpha=0.2)
plt.axvline(70,ls='--', color='k',alpha=0.8, label = r'$H_0 = 70$ (km s$^{-1}$ Mpc$^{-1}$)')
plt.plot(H0,posterior_uniform_norm, linewidth = 3.0, label='Posterior (Uniform)',c=c[0])
plt.axvline(a_uniform,ls='--',c=c[0])
plt.axvline(b_uniform,ls='--',c=c[0])
plt.plot(H0,posterior_log_norm,linewidth = 3.0, label='Posterior (Log)',c=c[1])
plt.axvline(a_log,ls='--',c=c[1])
plt.axvline(b_log,ls='--',c=c[1])
plt.plot(H0,prior_uniform_norm,ls=':', linewidth = 3.0, label='Prior (Uniform)',c=c[0],alpha=0.6)
plt.plot(H0,prior_log_norm,ls=':', linewidth = 3.0, label='Prior (Log)',c=c[1],alpha=0.6)
plt.xlim(min_H0,max_H0)
plt.ylim(ymin,ymax)
plt.xticks(fontsize=14)
plt.yticks(fontsize=14)
plt.xlabel(r'$H_0$ (km s$^{-1}$ Mpc$^{-1}$)',fontsize=16)
plt.ylabel(r'$p(H_0)$ (km$^{-1}$ s Mpc)', fontsize=16)
plt.legend(loc='upper right',fontsize=10)
plt.tight_layout()
plt.savefig(outputfile+'.png',dpi=800)