#!/usr/bin/env python
"""
This script computes posterior on H0 using a single gravitational wave event 
and an electromagnetic counterpart.

Rachel Gray
"""
# System imports
import pkg_resources
import os
import sys
from optparse import Option, OptionParser
import pickle


import numpy as np

import gwcosmo
from gwcosmo.utilities.posterior_utilities import confidence_interval
from gwcosmo.utilities.redshift_utilities import zhelio_to_zcmb
from gwcosmo.utilities.standard_cosmology import *
from gwcosmo.utilities.schechter_params import *
from gwcosmo.utilities.schechter_function import *

import astropy.constants as const
speed_of_light = const.c.to('km/s').value
data_path = pkg_resources.resource_filename('gwcosmo', 'data/')

def str2bool(v):
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')

# Command line options
parser = OptionParser(
    description = __doc__,
    usage = "%prog [options]",
    option_list = [
        Option("--pixel_index", default=0, type=int,
            help="index of the skymap pixel to analyse"),
        Option("--min_H0", default='20.0', type=float,
            help="Minimum value of H0"),
        Option("--max_H0", default='200.0', type=float,
            help="Maximum value of H0"),
        Option("--bins_H0", default='200', type=int,
            help="Number of H0 bins"),
        Option("--posterior_samples", default=None,
            help="Path to LALinference posterior samples file in format (.dat or hdf5)"),
        Option("--skymap", default=None,
            help="Path to LALinference 3D skymap file in format (.fits or fits.gz)"),
        Option("--Pdet", default=None,
            help="Path to precomputed probability of detection pickle"),
        Option("--galaxy_catalog", default=None,
            help="Path to galaxy catalogue in format (hdf5)"),
        Option("--galaxy_weighting", default='True',
            help="Weight potential host galaxies by luminosity? (Default=True)"),
        Option("--catalog_band", default='B', type=str,
            help = "Observation band of galaxy catalog (B,K,u,g,r,i,z) (must be compatible with the catalogue provided)"),
        Option("--assume_complete_catalog", default='False',
            help="Assume a complete catalog? (Default=False)"),
        Option("--redshift_uncertainty", default='True',
            help="Marginalise over redshift uncertainties (default=True)"),
        Option("--redshift_evolution", default='False',
            help="Allow GW host probability to evolve with redshift? (Default=False)"),
        Option("--Lambda", default='3.0', type=float,
            help="Set rate evolution parameter Lambda"),
        Option("--Kcorrections", default='False',
            help="Apply K-corrections."),
        Option("--reweight_posterior_samples", default='False',
            help="Reweight posterior samples with the same priors used to calculate the selection effects."),
        Option("--zmax", default='10.0', type=float,
            help="Upper redshift limit for integrals (default=10)"),
        Option("--zcut", default=None,
            help="Hard redshift cut to apply to the galaxy catalogue (default=None)"),
        Option("--mth", default=None,
            help="Override the apparent magnitude threshold of the catalogue, if provided (default=None)"),
        Option("--nside", default='32', type=int,
            help="skymap nside choice for reading in galaxies from the overlap of catalogue and skymap (default=64)"),
        Option("--sky_area", default='0.9999', type=float,
            help="contour boundary for galaxy catalogue method (default=0.9999)"), 
        Option("--return_skymap_indices", default='False',
            help="Return the skymap indices needed to run the pixelated method"),
        Option("--combine_pixels", default='False',
            help="combine multiple pixels to make the full likelihood for an event. Folder must contain pixel likelihoods and pixel indices file"),
        Option("--outputfile", default='Posterior',
            help="Name of output file")
    ])
opts, args = parser.parse_args()
print(opts)

# Check for missing required arguments
missing = []
for option in parser.option_list:
    if 'required' in option.help and eval('opts.' + option.dest) == None:
        missing.extend(option._long_opts)
if len(missing) > 0:
    parser.error('Missing required options: {0}'.format(str(missing)))

outputfile = str(opts.outputfile)
# Set command line arguments
min_H0 = float(opts.min_H0)
max_H0 = float(opts.max_H0)
bins_H0 = int(opts.bins_H0)
"Compute P(H0)"
H0 = np.linspace(min_H0, max_H0, bins_H0)
dH0 = H0[1] - H0[0]

combine_pixels = str2bool(opts.combine_pixels)
if combine_pixels:
    pixels = np.genfromtxt(outputfile+'_indices.txt',dtype=int)
    print('Combining {} pixels'.format(len(pixels)))
    likelihoods = np.zeros([len(H0),len(pixels)])
    for i, idx in enumerate(pixels):
        likelihoods[:,i] = np.load(outputfile+'_pixel_{}.npz'.format(idx),allow_pickle=True)['arr_0'][1]
    H0 = np.load(outputfile+'_pixel_{}.npz'.format(idx),allow_pickle=True)['arr_0'][0]
    likelihood = np.sum(likelihoods,axis=1)
    np.savez(outputfile+'_pixel_likelihood.npz',[H0, likelihood])

else:
    if (opts.posterior_samples is None):
        parser.error('Currently all methods are implemented to work with posterior samples. \
                      We are working to add skymap compatability as soon as possible.')

    if opts.Pdet is None:
        parser.error('Provide a precomputed probability of detection.')

    if opts.posterior_samples is not None:
        posterior_samples = str(opts.posterior_samples)

    redshift_evolution = str2bool(opts.redshift_evolution)
    Lambda = float(opts.Lambda)
    reweight_samples = str2bool(opts.reweight_posterior_samples)
    pdet_path = str(opts.Pdet)
    zmax = float(opts.zmax)

    return_skymap_indices = str2bool(opts.return_skymap_indices)
    pixel_index = int(opts.pixel_index)


    pdet = pickle.load(open(pdet_path, 'rb'))
    mass_distribution = pdet.mass_distribution
    mass_slope = pdet.alpha
    psd = pdet.asd
    Mmin = pdet.Mmin
    Mmax = pdet.Mmax
    network_snr_threshold = pdet.snr_threshold

    print('Loading precomputed pdet with a {} mass distribution at {} sensitivity assuming an SNR threshold of {}.'.format(mass_distribution, psd, network_snr_threshold))
    if mass_distribution == 'BBH-powerlaw':
        print('Mass distribution parameters: alpha=-{}, Mmin={}, Mmax={}'.format(mass_slope, Mmin, Mmax))

    Omega_m = pdet.Omega_m
    linear_cosmo = pdet.linear
    zprior = redshift_prior(Omega_m=Omega_m, linear=linear_cosmo)
    cosmo = fast_cosmology(Omega_m=Omega_m, linear=linear_cosmo)
    if redshift_evolution:
        ps_z = gwcosmo.gwcosmo.RedshiftEvolution()
    else:
        ps_z = gwcosmo.gwcosmo.RedshiftNonEvolution()

    print('Setting up a cosmology with Omega_m={}'.format(Omega_m))

    skymap_path = str(opts.skymap)
    skymap = gwcosmo.likelihood.skymap.skymap(skymap_path)
    sky_area = float(opts.sky_area)

    print("Loading posterior samples.")
    samples = gwcosmo.likelihood.posterior_samples.posterior_samples(posterior_samples)
    pixelated_samples = gwcosmo.likelihood.posterior_samples.make_pixel_px_function(samples, skymap, npixels=30, thresh=sky_area)

    if return_skymap_indices:
        np.savetxt(outputfile+'_indices.txt',pixelated_samples.indices,fmt='%i')
        exit()

    px_zH0 = gwcosmo.likelihood.posterior_samples.make_px_function(samples, H0, reweight_samples=reweight_samples, mass_distribution=mass_distribution, alpha=mass_slope, mmin=Mmin, mmax=Mmax)

    if (opts.galaxy_catalog is None):
        parser.error('Provide a galaxy catalogue.')
        
    if (opts.skymap is None):
        parser.error('Provide a gravitational wave skymap')
        

    catalog_path = str(opts.galaxy_catalog)
    band = str(opts.catalog_band)
    Kcorr = str2bool(opts.Kcorrections)
    zuncert = str2bool(opts.redshift_uncertainty)
    galaxy_weighting = str2bool(opts.galaxy_weighting)
    nside = int(opts.nside)

    complete_catalog = str2bool(opts.assume_complete_catalog)
    if opts.mth is not None:
        if opts.mth == 'inf':
            mth = np.inf
        else:
            mth = float(opts.mth)
    else:
        mth = None
    if opts.zcut is not None:
        zcut = float(opts.zcut)
    else:
        zcut = None

    nside_low_res = pixelated_samples.nside
    catalog = gwcosmo.prior.catalog.galaxyCatalog(catalog_file=catalog_path,skymap=skymap,band=band,thresh=sky_area,Kcorr=Kcorr,nside=nside_low_res,pixelate_catalog=True)
    sp = SchechterParams(catalog.band)

    p_M = SchechterMagFunction(Mstar_obs=sp.Mstar,alpha=sp.alpha)
    if galaxy_weighting:
        ps_M = gwcosmo.gwcosmo.LuminosityWeighting()
    else:
        ps_M = gwcosmo.gwcosmo.UniformWeighting()
        
    samp_ind = pixelated_samples.identify_samples(pixel_index, minsamps=100)
    px_zH0 = pixelated_samples.make_los_px_function(samp_ind,H0,reweight_samples=True,mass_distribution='BBH-powerlaw',alpha=1.6,mmin=5.0,mmax=100.)

    me = gwcosmo.gwcosmo.SinglePixelGalaxyCatalogLikelihood(pixel_index, catalog, skymap, band, cosmo,\
                                                          px_zH0, pdet.pD_zH0_eval, zprior, ps_z, p_M, \
                                                          ps_M, Kcorr=Kcorr, mth=mth, zcut=zcut, \
                                                          zmax=zmax,zuncert=zuncert, complete_catalog=complete_catalog,nside=nside)

    likelihood = me(H0,Lambda=Lambda)
    pxG, pDG, pG, pxB, pDB, pB, pxO, pDO, pO = me.return_components()

    np.savez(outputfile+'_pixel_{}.npz'.format(pixel_index),[H0, likelihood, pxG, pDG, pG, pxB, pDB, pB, pxO, pDO, pO])

