#!/usr/bin/python

"""
This script computes H0 as a function of H0 bins.
"""
__author__ = "Ignacio Magana Hernandez <ignacio.magana@ligo.org>"

# System imports
import os
import sys
from optparse import Option, OptionParser

# Command line options
parser = OptionParser(
    description = __doc__,
    usage = "%prog [options]",
    option_list = [
        Option("-m", "--method", metavar="METHOD", default=None,
            help="METHOD: Select counterpart/statistical/pencil_beam method (required)"),
        Option("-a", "--min_h0", metavar="MINH0", default='10.0',
            help="MINH0: Set minimum value of H0 Posterior"),
        Option("-b", "--max_h0", metavar="MAXH0", default='220.0',
            help="MAXH0: Set maximum value of H0 Posterior"),
        Option("-c", "--bins_h0", metavar="BINSH0", default='210.0',
            help="BINSH0: Set number of H0 Posterior bins"),
        Option("-d", "--min_dist", metavar="MINDIST", default='0.1',
            help="MINDIST: Set minimum value of luminosity distance"),
        Option("-e", "--max_dist", metavar="MAXDIST", default='400.0',
            help="MAXDIST: Set maximum value of luminosity distance"),
        Option("-f", "--bins_dist", metavar="BINSDIST", default=None, # Options below need to be implemented
            help="BINSDIST: Set number of luminosity distance bins"),
        Option("-g", "--galaxycatalog", metavar="FILE", default=None,
            help="Galaxy Catalog FILE in format (.xml)"),
        Option("-p", "--posteriorsamples", metavar="FILE", default=None,
            help="LALinference Posterior Samples FILE in format (.dat or hdf5)"),
        Option("-r", "--counterpartra", metavar="RA", default=None,
            help="RA of counterpart"),
        Option("-o", "--counterpartdec", metavar="DEC", default=None,
            help="DEC of counterpart")
    ])
opts, args = parser.parse_args()

# Check for missing required arguments
missing = []
for option in parser.option_list:
    if 'required' in option.help and eval('opts.' + option.dest) == None:
        missing.extend(option._long_opts)
if len(missing) > 0:
    parser.error('Missing required options: {0}'.format(str(missing)))

print 'Selected method is:', opts.method

# Global Imports
import numpy as np
import matplotlib 
matplotlib.use('agg')
import matplotlib.pyplot as plt
from astropy import units as u
from astropy import constants as const
from scipy import stats, random

# Global variables
z_err_fraction = 0.06
a_err_fraction = 0.08

# Set to 1.0 to use NGC4993 only, else set to 0.0
if opts.method == 'statistical':
    useNGC4993only = 0
    cfactor = 1.0
else:
    useNGC4993only = 1
    gname = 'NGC4993'
    cfactor = 1.0

def main():
    "Compute P(H0)"
    import gwcosmo
    from gwcosmo.prior.completion import completionFunction
    from gwcosmo.prior.catalog import catalog
    from gwcosmo.likelihood.gw import posterior_samples

    # Set command line arguments
    min_h0 = float(opts.min_h0)
    max_h0 = float(opts.max_h0)
    bins_h0 = float(opts.bins_h0)

    distmax = float(opts.max_dist)
    distmin = float(opts.min_dist)

    options_string = opts.method

    hzero = np.linspace(min_h0, max_h0, bins_h0)

    # Compute normalization
    if useNGC4993only > 0:
        catalog = catalog()
        pgcCat, ra, dec, dist, z, lumB, angle_error, dist_err, z_err = catalog.generate_catalog_counterpart()
        completionFun = completionFunction()
    else:
        catalog = catalog()
        pgcCat, ra, dec, dist, z, lumB, angle_error, dist_err, z_err = catalog.generate_catalog()
        completionFun = completionFunction()                                                       

    normalization = np.ones(len(hzero))
    for k, x in enumerate(hzero):
        zmax = ((distmax * u.Mpc) * (x * u.km / u.s / u.Mpc) / const.c.to('km/s')).value
        tmpz = np.linspace(0.00001,zmax,100)
        coverh = (const.c.to('km/s') / (x * u.km / u.s / u.Mpc)).value
        tmpr = z * coverh
        epsilon = 0.5 * (1 - np.tanh(3.3 * np.log(tmpr / 80.)))
        epLumB = lumB * epsilon
        dz = tmpz[1] - tmpz[0]
        completion = cfactor * completionFun.generateCompletion(lumB, dist, tmpz, useNGC4993only)
        epsilon = 0.5 * (1 - np.tanh(3.3 * np.log(coverh * tmpz / 80.)))
        tmpnorm = 0.0
        tmpnorm = np.sum(epLumB) + np.sum(epsilon * completion) * dz
        normalization[k] = tmpnorm
        
    aofh = (hzero**3) / normalization

    print 'Normalization computed.'

    # Plot normalization
    normalization_file = "normalization_" + options_string
    fig, ax = plt.subplots()
    plt.plot(hzero, aofh,'g+', label='$f^{-1}\,(H_0)$')
    ax.set_xlabel('$H_0$', size='large')
    ax.set_ylabel('$f^{-1}\,(H_0)$', size='large')
    ax.legend(loc='upper left', shadow=True, fontsize='large')
    fname = normalization_file +'.pdf'
    plt.savefig(fname, format='pdf')
    plt.close()

    # Load posterior samples
    posterior_samples = posterior_samples()
    lalinference_data, distance, longitude, latitude, weight, nsamples, ngalaxies = posterior_samples.load_posterior_samples()

    # Select relevant galaxies
    # FIX CLUNKY CODE #
    ph = np.zeros(len(hzero))
    t = catalog.catalog
    if useNGC4993only > 0:
        nt = t
        ngalaxies = 0
    else:
        nt = t[np.argmax(t['Distance'] > distmin):np.argmin(t['Distance'] < distmax)]

        nt.sort('RA')
        nt = nt[np.argmax(nt['RA'] > np.min(longitude) - 1.0):np.argmin(nt['RA'] < np.max(longitude ) +1.0)]

        nt.sort('Dec')
        nt = nt[np.argmax(nt['Dec'] > np.min(latitude) - 1.0):np.argmin(nt['Dec'] < np.max(latitude ) + 1.0)]

    catalog.catalog = nt
    (pgcCat, ra, dec, dist, z, lumB, angle_error, dist_err, z_err) = catalog.extract_galaxies_table()

    tmpra = np.transpose(np.tile(ra, (len(longitude[ngalaxies:]), 1))) - np.tile(longitude[ngalaxies:], (len(ra), 1))
    tmpdec = np.transpose(np.tile(dec, (len(latitude[ngalaxies:]), 1))) - np.tile(latitude[ngalaxies:], (len(dec), 1))
    tmpm = np.power(tmpra, 2.) + np.power(tmpdec, 2.)
    mask1 = np.ma.masked_where(tmpm > (a_err_fraction**2), tmpm).filled(0)
    mask1 = np.max((mask1 > 0), 1)

    ra = ra[mask1]
    dec = dec[mask1]
    dist = dist[mask1]
    z = z[mask1]
    lumB = lumB[mask1]
    # CLUNKY CODE END#

    print "No. of used galaxies %i" % (len(ra))

    # Calculate posterior
    for k, x in enumerate(hzero):
        coverh = (const.c.to('km/s') / (x * u.km / u.s / u.Mpc)).value
        pdf = stats.gaussian_kde(np.vstack((longitude[nsamples:], latitude[nsamples:], distance[nsamples:] / coverh)))
        pdfnorm = pdf.integrate_box(np.asarray([0, -np.pi / 2, 0]), np.asarray([2.0 * np.pi, np.pi / 2, 1.0]))
        tmppdf = pdf(np.vstack((ra, dec, z))) / pdfnorm
        ph[k] = np.sum(tmppdf * lumB / (np.cos(dec) * z**2))
        completion = cfactor * completionFun.generateCompletion(lumB, dist, distance / coverh, useNGC4993only) / (4.0 * np.pi)
        epsilon = 0.5 * (1 - np.tanh(3.3 * np.log(distance / 80.)))
        ph[k] = (ph[k] + np.mean((completion ) / ((distance / coverh)**2)))

        print "Calculating posterior at H0 bin: %i" % x

    print 'Posterior computed.'

    # Save data
    posterior_file = "posterior_" + options_string
    np.savez(posterior_file + options_string + '.npz', hzero, ph, aofh)

    # Plot posterior
    fig, ax = plt.subplots()
    fig.set_size_inches(20, 8)
    tmpp = ph * aofh / hzero
    dh = hzero[1] - hzero[0]
    tmpp = tmpp / np.sum(tmpp * dh)
    ax.plot(hzero, tmpp, linewidth=2, label='Log Prior')
    ax.plot(hzero, tmpp[-1] * np.power(hzero, -1.0) / (np.power(hzero, -1.0)[-1]), 'g-.', label='$H_0^{-1}$')
    tmpp = ph * aofh
    tmpp = tmpp / np.sum(tmpp * dh)
    ax.plot(hzero, tmpp, linewidth=2, label='Uniform Prior')
    ax.axvline(70., 0.0, 1, color='r', label='$H_0$ = 70 (km s$^{-1}$ Mpc$^{-1}$)')
    ax.set_xlabel('$H_0$ (km s$^{-1}$ Mpc$^{-1}$)', size='large')
    ax.set_ylabel('$p(H_0|data)$ (km$^{-1}$ s Mpc)', size='large')
    ax.legend(loc='upper right', shadow=True, fontsize='medium')
    fname = posterior_file +'.pdf'
    fig.savefig(fname, format='pdf')
    plt.close()

    return 0

if __name__ == "__main__":
    main()